# React Notes

## 概念详解

1. 状态改变 -> 构建新的 DOM 元素更新页面
- 一旦状态发生改变，就重新调用 render 方法，构建一个新的 DOM 元素
1. JSX
- JSX 是 JavaScript 语言的一种语法扩展，长得像 HTML，但并不是 HTML
- React.js 可以用 JSX 来描述你的组件长什么样的
- JSX 在编译的时候会变成相应的 JavaScript 对象描述
- react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素，并且渲染到页面上

![jsx](./img/jsx_flow.png)

- JSX 元素就是 JavaScript 对象
- 自定义的组件都必须要用大写字母开头，普通的 HTML 标签都用小写字母开头。
- 监听：React.js 帮我们封装好了一系列的 on* 的属性,必须要用驼峰命名法

### event对象

- 和普通浏览器一样，事件监听函数会被自动传入一个 event 对象，这个对象和普通的浏览器 event 对象所包含的方法和属性都基本一致
- React.js 的事件监听方法需要手动 bind 到当前实例，这种模式在 React.js 中非常常用。

### setState

- 调用后，React.js 会更新组件的状态 state ，并且重新调用 render 方法，然后再把 render 方法所渲染的最新的内容显示到页面上。
- 接受一个对象或者函数作为参数
- 传入一个对象的时候，这个对象表示该组件的新状态， 只需要传入需要更新的部分就可以了，而不需要传入整个对象。
- 调用 setState 的时候，React.js 并不会马上修改 state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新
- 并不需要担心多次进行 setState 会带来性能问题

### props

- 在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为 props 对象的键值
- 可以把任何类型的数据作为组件的参数，包括字符串、数字、对象、数组、甚至是函数等等
- props 一旦传入进来就不能改变
- defaultProps，可以方便的做到默认配置
- props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件

### state

- state 的主要作用是用于组件保存、控制、修改自己的可变状态
- state 是让组件控制自己的状态，props 是让外部对组件自己进行配置
- 尽量少地用 state，尽量多地用 props
- 没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）
- 因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件,会降低代码维护的难度，也会在一定程度上增强组件的可复用性
- 函数式组件就是一种只能接受 props 和提供 render 方法的类组件。

### 渲染列表数据

- 往 {} 放一个数组，React.js 会帮你把数组里面一个个元素罗列并且渲染出来。
- 对于用表达式套数组罗列到页面上的元素，都要为每个元素加上 key 属性，这个 key 必须是每个元素唯一的标识。

### 组件

- React.js 中一切都是组件，用 React.js 构建的功能其实也就是由各种组件组合而成。所以拿到一个需求以后，我们要做的第一件事情就是理解需求、分析需求、划分这个需求由哪些组件构成。
- 划分组件的目的性是为了代码可复用性、可维护性
- 遵循“自顶而下，逐步求精”的原则

## 第二阶段

### 状态提升

- 当某个状态被多个组件依赖或者影响的时候，就把该状态提升到这些组件的最近公共父组件中去管理，用 props 传递数据或者函数来管理这种依赖或着影响的行为。

### 组件生命周期

- React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载
- React.js 会在组件的 render 之前调用 `componentWillMount`，在 DOM 元素塞入页面以后调用 `componentDidMount`，都是可以像 render 方法一样自定义在组件的内部
- 在组件删除之前 React.js 会调用组件定义的 `componentWillUnmount`
- 一般会把组件的 state 的初始化工作放在 `constructor` 里面去做；在 `componentWillMount` 进行组件的启动工作，例如 Ajax 数据拉取、定时器的启动；组件从页面上销毁的时候，有时候需要一些数据的清理，例如定时器的清理，就会放在 `componentWillUnmount` 里面去做。
- `shouldComponentUpdate(nextProps, nextState)`：你可以通过这个方法控制组件是否重新渲染。如果返回 false 组件就不会重新渲染。这个生命周期在 React.js 性能优化上非常有用。
- `componentWillReceiveProps(nextProps)`：组件从父组件接收到新的 props 之前调用。
- `componentWillUpdate()`：组件开始重新渲染之前调用。
- `componentDidUpdate()`：组件重新渲染并且把更改变更到真实的 DOM 以后调用。
- Virtual DOM 算法, 包括几个步骤:
  - 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
  - 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
  - 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了

### 组件明细

- 所有嵌套在组件中的 JSX 结构都可以在组件内部通过 props.children 获取到一个数组
- 一个原则：能不用 ref 就不用
- 元素加了一个 ref 属性，这个属性值是一个函数
- 给 `dangerouslySetInnerHTML`传入一个对象，这个对象的 __html 属性值就相当于元素的 innerHTML
- `style` 接受一个对象，这个对象里面是这个元素的 CSS 属性键值对，原来 CSS 属性中带 - 的元素都必须要去掉 - 换成驼峰命名，如 font-size 换成 fontSize，text-align 换成 textAlign。
  - 用对象作为 style 方便我们动态设置元素的样式。我们可以用 props 或者 state 中的数据生成样式对象再传给元素
- 给组件的配置参数加上类型验证
  - 组件参数验证在构建大型的组件库的时候相当有用，可以帮助我们迅速定位这种类型错误，让我们组件开发更加规范。
  - 组件到底能够接受什么参数，什么参数是可选的，什么参数是必选的
  - 组件的私有方法都用 _ 开头，所有事件监听的方法都用 handle 开头。把事件监听方法传给组件的时候，属性名用 on 开头。
  - 组件的内容编写顺序如下:
    - static 开头的类属性，如 defaultProps、propTypes
    - 构造函数，constructor
    - getter/setter
    - 组件生命周期
    - _ 开头的私有方法
    - 事件监听方法，handle*
    - render\*开头的方法，有时候 render() 方法里面的内容会分开到不同函数里面进行，这些函数都以 render* 开头
    - render() 方法

### 高阶组件

- 高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。
- 为了组件之间的代码复用:
  - 组件可能有着某些相同的逻辑，把这些逻辑抽离出来，放到高阶组件中进行复用;
  - 高阶组件内部的包装组件和被包装组件之间通过 props 传递数据
  - 它其实就是设计模式里面的装饰者模式: 可以用类继承来做到代码复用;也可以分离模块的方式
  - context: 组件只要往自己的 context 里面放了某些状态，这个组件之下的所有子组件都直接访问这个状态而不需要通过中间组件的传递。
    - 一个组件的 context 只有它的子组件能够访问，它的父组件是不能访问到的
    - 给组件设置 context，那么 childContextTypes 是必写的
  - 纯函数（Pure Function）:
    - 函数的返回结果只依赖于它的参数
    - 函数执行过程里面没有副作用
      - 一个函数执行过程对产生了外部可观察的变化那么就说这个函数是有副作用的
      - 除了修改外部的变量，一个函数在执行过程中还有很多方式产生外部可观察的变化，比如说调用 DOM API 修改页面，或者你发送了 Ajax 请求，还有调用 window.reload 刷新浏览器，甚至是 console.log 往控制台打印数据也是副作用